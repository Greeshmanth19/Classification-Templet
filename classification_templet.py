# -*- coding: utf-8 -*-
"""Classification Templet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11HH4WRHvp-k6xmlNWegOAgUaRnk4uM9c
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score, ConfusionMatrixDisplay

data = pd.read_csv("Upload file path in csv formate")
data.head()

data.isnull().sum()

data.describe()

model = []
acc = []
precision = []
recall = []
f1 = []

# make sure that dependent variable is at the last column
X = data.iloc[:,:-1].values
y = data.iloc[:,-1:].values

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42)

sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

"""# LogisticRegression"""

from sklearn.linear_model import LogisticRegression
LR = LogisticRegression()
LR.fit(X_train, y_train)
LR_y_p = LR.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, LR_y_p), display_labels=LR.classes_)
disp.plot()
plt.show()

model.append("LogisticRegression")
acc.append(accuracy_score(y_test, LR_y_p))
precision.append(precision_score(y_test, LR_y_p))
recall.append(recall_score(y_test, LR_y_p))
f1.append(f1_score(y_test, LR_y_p))

"""# K-Nearest-Neighbor (KNN)"""

from sklearn.neighbors import KNeighborsClassifier
KNN = KNeighborsClassifier(n_neighbors=5)      # k value can be any odd value that works well for your data
KNN.fit(X_train, y_train)
KNN_y_p = KNN.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, KNN_y_p), display_labels=KNN.classes_)
disp.plot()
plt.show()

model.append("K-Nearest-Neighbor (KNN)")
acc.append(accuracy_score(y_test, KNN_y_p))
precision.append(precision_score(y_test, KNN_y_p))
recall.append(recall_score(y_test, KNN_y_p))
f1.append(f1_score(y_test, KNN_y_p))

"""# Support Vector Machine (SVM)"""

from sklearn.svm import SVC
SVC = SVC(kernel = "rbf")  # if your data is linearly separable then use linear kernal or use non-linear kernals like rbf....
SVC.fit(X_train, y_train)
SVC_y_p = SVC.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, SVC_y_p), display_labels=SVC.classes_)
disp.plot()
plt.show()

model.append("Support Vector Machine (SVM)")
acc.append(accuracy_score(y_test, SVC_y_p))
precision.append(precision_score(y_test, SVC_y_p))
recall.append(recall_score(y_test, SVC_y_p))
f1.append(f1_score(y_test, SVC_y_p))

"""# Decision Tree"""

from sklearn.tree import DecisionTreeClassifier
DT = DecisionTreeClassifier(criterion="entropy")
DT.fit(X_train, y_train)
DT_y_p = DT.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, DT_y_p), display_labels=DT.classes_)
disp.plot()
plt.show()

model.append("Decision Tree")
acc.append(accuracy_score(y_test, DT_y_p))
precision.append(precision_score(y_test, DT_y_p))
recall.append(recall_score(y_test, DT_y_p))
f1.append(f1_score(y_test, DT_y_p))

"""# Random Forest"""

from sklearn.ensemble import RandomForestClassifier
RF = RandomForestClassifier(n_estimators=100)
RF.fit(X_train, y_train)
RF_y_p = RF.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, RF_y_p), display_labels=RF.classes_)
disp.plot()
plt.show()

model.append("Random Forest")
acc.append(accuracy_score(y_test, RF_y_p))
precision.append(precision_score(y_test, RF_y_p))
recall.append(recall_score(y_test, RF_y_p))
f1.append(f1_score(y_test, RF_y_p))

"""# Naive Bayes"""

from sklearn.naive_bayes import GaussianNB
NB = GaussianNB()
NB.fit(X_train, y_train)
NB_y_p = NB.predict(X_test)

disp = ConfusionMatrixDisplay(confusion_matrix=confusion_matrix(y_test, NB_y_p), display_labels=NB.classes_)
disp.plot()
plt.show()

model.append("Naive Bayes")
acc.append(accuracy_score(y_test, NB_y_p))
precision.append(precision_score(y_test, NB_y_p))
recall.append(recall_score(y_test, NB_y_p))
f1.append(f1_score(y_test, NB_y_p))

"""# Performance Evaluation"""

results = pd.DataFrame({"Classification Model":model, "Accuracy Score":acc, "Predision Score":precision, "Recall Score":recall, "F1 Score":f1})
results

results.sort_values(by="Accuracy Score", ascending=False)
results